import jsPDF from 'jspdf';
import * as XLSX from 'xlsx';
import { PaymentScheduleItem, EMICalculation, EMIInput } from '../types';
import { formatCurrency, formatNumber } from './calculations';
import { format } from 'date-fns';

export const exportToPDF = (
  calculation: EMICalculation,
  inputs: EMIInput,
  schedule: PaymentScheduleItem[],
  calculatorType: string = 'EMI'
) => {
  const doc = new jsPDF();
  
  // Title
  doc.setFontSize(20);
  doc.text(`${calculatorType} Calculator Report`, 20, 30);
  
  // Date
  doc.setFontSize(10);
  doc.text(`Generated on: ${format(new Date(), 'dd/MM/yyyy HH:mm')}`, 20, 40);
  
  // Input Details
  doc.setFontSize(14);
  doc.text('Loan Details:', 20, 60);
  
  doc.setFontSize(10);
  let yPos = 70;
  
  if (calculatorType === 'EMI') {
    doc.text(`Loan Type: ${inputs.loanType.charAt(0).toUpperCase() + inputs.loanType.slice(1)} Loan`, 20, yPos);
    yPos += 10;
    doc.text(`Principal Amount: ${formatCurrency(inputs.principal)}`, 20, yPos);
    yPos += 10;
    doc.text(`Interest Rate: ${inputs.interestRate}% per annum`, 20, yPos);
    yPos += 10;
    doc.text(`Loan Term: ${inputs.term} ${inputs.termUnit}`, 20, yPos);
    yPos += 10;
    doc.text(`Start Date: ${format(inputs.startDate, 'dd/MM/yyyy')}`, 20, yPos);
    yPos += 10;
    doc.text(`Payment Frequency: ${inputs.paymentFrequency}`, 20, yPos);
    yPos += 20;
  }
  
  // Results Summary
  doc.setFontSize(14);
  doc.text('Calculation Results:', 20, yPos);
  yPos += 10;
  
  doc.setFontSize(10);
  doc.text(`Monthly EMI: ${formatCurrency(calculation.emi)}`, 20, yPos);
  yPos += 10;
  doc.text(`Total Payment: ${formatCurrency(calculation.totalPayment)}`, 20, yPos);
  yPos += 10;
  doc.text(`Total Interest: ${formatCurrency(calculation.totalInterest)}`, 20, yPos);
  yPos += 10;
  doc.text(`Principal Amount: ${formatCurrency(calculation.principal)}`, 20, yPos);
  yPos += 20;
  
  // Payment Schedule Summary (first 12 months)
  if (schedule.length > 0) {
    doc.setFontSize(14);
    doc.text('Payment Schedule (First 12 Months):', 20, yPos);
    yPos += 10;
    
    doc.setFontSize(8);
    doc.text('Month', 20, yPos);
    doc.text('Date', 50, yPos);
    doc.text('EMI', 80, yPos);
    doc.text('Principal', 110, yPos);
    doc.text('Interest', 140, yPos);
    doc.text('Balance', 170, yPos);
    yPos += 10;
    
    schedule.slice(0, 12).forEach((payment, index) => {
      if (yPos > 270) {
        doc.addPage();
        yPos = 20;
      }
      
      doc.text(payment.month.toString(), 20, yPos);
      doc.text(format(payment.date, 'MMM yy'), 50, yPos);
      doc.text(formatNumber(payment.emi), 80, yPos);
      doc.text(formatNumber(payment.principal), 110, yPos);
      doc.text(formatNumber(payment.interest), 140, yPos);
      doc.text(formatNumber(payment.balance), 170, yPos);
      yPos += 8;
    });
  }
  
  // Footer
  doc.setFontSize(8);
  doc.text('Generated by EMI Calculator App - For informational purposes only', 20, 290);
  
  doc.save(`${calculatorType.toLowerCase()}-calculation-${format(new Date(), 'yyyy-MM-dd')}.pdf`);
};

export const exportToExcel = (
  calculation: EMICalculation,
  inputs: EMIInput,
  schedule: PaymentScheduleItem[],
  calculatorType: string = 'EMI'
) => {
  const workbook = XLSX.utils.book_new();
  
  // Summary Sheet
  const summaryData = [
    ['EMI Calculator Report'],
    ['Generated on:', format(new Date(), 'dd/MM/yyyy HH:mm:ss')],
    [''],
    ['Loan Details:'],
    ...(calculatorType === 'EMI' ? [
      ['Loan Type:', inputs.loanType.charAt(0).toUpperCase() + inputs.loanType.slice(1) + ' Loan'],
      ['Principal Amount:', inputs.principal],
      ['Interest Rate (% p.a.):', inputs.interestRate],
      ['Loan Term:', `${inputs.term} ${inputs.termUnit}`],
      ['Start Date:', format(inputs.startDate, 'dd/MM/yyyy')],
      ['Payment Frequency:', inputs.paymentFrequency],
    ] : []),
    [''],
    ['Calculation Results:'],
    ['Monthly EMI:', calculation.emi],
    ['Total Payment:', calculation.totalPayment],
    ['Total Interest:', calculation.totalInterest],
    ['Principal Amount:', calculation.principal],
    ['Interest as % of Total:', ((calculation.totalInterest / calculation.totalPayment) * 100).toFixed(2) + '%'],
  ];
  
  const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
  XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');
  
  // Payment Schedule Sheet
  if (schedule.length > 0) {
    const scheduleData = [
      ['Month', 'Date', 'EMI Amount', 'Principal', 'Interest', 'Outstanding Balance'],
      ...schedule.map(payment => [
        payment.month,
        format(payment.date, 'dd/MM/yyyy'),
        payment.emi,
        payment.principal,
        payment.interest,
        payment.balance
      ])
    ];
    
    const scheduleSheet = XLSX.utils.aoa_to_sheet(scheduleData);
    
    // Add formatting
    const range = XLSX.utils.decode_range(scheduleSheet['!ref'] || 'A1');
    for (let C = range.s.c; C <= range.e.c; ++C) {
      const address = XLSX.utils.encode_col(C) + '1';
      if (!scheduleSheet[address]) continue;
      scheduleSheet[address].s = {
        font: { bold: true },
        fill: { fgColor: { rgb: 'CCCCCC' } }
      };
    }
    
    XLSX.utils.book_append_sheet(workbook, scheduleSheet, 'Payment Schedule');
  }
  
  // Yearly Summary Sheet
  if (schedule.length > 0) {
    const yearlyData = schedule.reduce((acc, payment) => {
      const year = payment.year;
      if (!acc[year]) {
        acc[year] = { year, emi: 0, principal: 0, interest: 0, payments: 0 };
      }
      acc[year].emi += payment.emi;
      acc[year].principal += payment.principal;
      acc[year].interest += payment.interest;
      acc[year].payments += 1;
      return acc;
    }, {} as Record<number, any>);
    
    const yearlyArray = [
      ['Year', 'Payments', 'Total EMI', 'Total Principal', 'Total Interest'],
      ...Object.values(yearlyData).map((year: any) => [
        year.year,
        year.payments,
        year.emi,
        year.principal,
        year.interest
      ])
    ];
    
    const yearlySheet = XLSX.utils.aoa_to_sheet(yearlyArray);
    XLSX.utils.book_append_sheet(workbook, yearlySheet, 'Yearly Summary');
  }
  
  XLSX.writeFile(workbook, `${calculatorType.toLowerCase()}-calculation-${format(new Date(), 'yyyy-MM-dd')}.xlsx`);
};

export const generateShareableURL = (
  inputs: any,
  calculatorType: string
): string => {
  const baseURL = window.location.origin + window.location.pathname;
  const params = new URLSearchParams();
  
  params.set('calculator', calculatorType);
  
  // Encode inputs as URL parameters
  Object.keys(inputs).forEach(key => {
    const value = inputs[key];
    if (value !== null && value !== undefined) {
      if (typeof value === 'object' && value instanceof Date) {
        params.set(key, value.toISOString());
      } else if (Array.isArray(value)) {
        params.set(key, JSON.stringify(value));
      } else {
        params.set(key, value.toString());
      }
    }
  });
  
  return `${baseURL}?${params.toString()}`;
};

export const parseURLParams = (): { calculatorType: string; inputs: any } | null => {
  const urlParams = new URLSearchParams(window.location.search);
  const calculatorType = urlParams.get('calculator');
  
  if (!calculatorType) return null;
  
  const inputs: any = {};
  
  urlParams.forEach((value, key) => {
    if (key === 'calculator') return;
    
    try {
      // Try to parse as JSON first (for arrays and objects)
      if (value.startsWith('[') || value.startsWith('{')) {
        inputs[key] = JSON.parse(value);
      } else if (value.includes('T') && value.includes('Z')) {
        // Parse as date
        inputs[key] = new Date(value);
      } else if (!isNaN(Number(value))) {
        // Parse as number
        inputs[key] = Number(value);
      } else if (value === 'true' || value === 'false') {
        // Parse as boolean
        inputs[key] = value === 'true';
      } else {
        // Keep as string
        inputs[key] = value;
      }
    } catch (error) {
      // If parsing fails, keep as string
      inputs[key] = value;
    }
  });
  
  return { calculatorType, inputs };
};

export const copyToClipboard = async (text: string): Promise<boolean> => {
  try {
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(text);
      return true;
    } else {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      const success = document.execCommand('copy');
      textArea.remove();
      return success;
    }
  } catch (error) {
    console.error('Failed to copy to clipboard:', error);
    return false;
  }
};